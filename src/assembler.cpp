#include <fstream>
#include <iostream>
#include <iomanip>
#include "/home/ss/Desktop/Projekat/inc/assembler.hpp"
#include "/home/ss/Desktop/Projekat/inc/assemblerLexer.hpp"
using namespace std;

int idCountSymbolTable = 0;
int idCountSectionTable = 0;
regex file("(.*).o");

/*
#!/bin/bash
g++ -o asembler src/asMain.cpp src/assembler.cpp

g++ -o linker src/ldMain.cpp src/linker.cpp

#!/bin/bash
g++ -o emulator src/eMain.cpp src/emulator.cpp
*/

/*
test1
ASSEMBLER=/home/ss/Desktop/Projekat/asembler
LINKER=/home/ss/Desktop/Projekat/linker
#EMULATOR=/home/ss/Desktop/Projekat/emulator

${ASSEMBLER} -o directives.o directives.s
${ASSEMBLER} -o directives-2.o directives-2.s
${LINKER} -hex -place=ivt@0x0000 -o test1.hex directives.o directives-2.o
#${EMULATOR} test1.hex

# nije stvoren za pokretanje samo za linkera

# 0000: 00 00 00 00 00 00 00 00
# 0008: 00 00 00 00 00 00 00 00
# 0010: 04 00 19 00 00 00 25 00
# 0018: 06 00 00 00 6c 6f 6c 0a
# 0020: 00 02 00 03 00 04 00

test2

ASSEMBLER=/home/ss/Desktop/Projekat/asembler
LINKER=/home/ss/Desktop/Projekat/linker
EMULATOR=/home/ss/Desktop/Projekat/emulator

${ASSEMBLER} -o find-max.o find-max.s
${ASSEMBLER} -o instructions.o instructions.s
${LINKER} -hex -place=ivt@0x0000 -o test2.hex find-max.o instructions.o
${EMULATOR} test2.hex


# linker

# 0000: 10 00 00 00 9d 00 ae 00
# 0008: 00 00 00 00 00 00 c9 00
# 0010: a0 2f 00 00 07 b0 2f 04
# 0018: ff 10 a0 0f 00 00 01 a0
# 0020: 1f 00 01 37 b0 01 02 a0
# 0028: 1f 00 01 33 a0 01 03 00
# 0030: 04 a0 11 03 00 04 74 01
# 0038: 10 2f 51 ff 00 00 4a a0
# 0040: 0f 00 00 45 b0 0f 04 ff
# 0048: 00 00 70 01 74 01 52 ff
# 0050: 00 00 5e a0 0f 00 00 45
# 0058: b0 0f 04 ff 00 00 82 01
# 0060: 53 ff 00 00 70 a0 0f 00
# 0068: 00 45 b0 0f 04 ff 00 00
# 0070: 90 01 91 11 84 01 51 ff
# 0078: 00 00 86 a0 0f 00 00 45
# 0080: b0 0f 04 ff 00 00 30 f7
# 0088: 05 00 5c a0 1f 00 00 30
# 0090: 70 01 b0 0f 04 ff 00 50
# 0098: ff 00 00 97 00 b0 06 12
# 00a0: a0 07 03 00 8e b0 0f 04
# 00a8: ff 00 a0 06 42 00 b0 06
# 00b0: 12 a0 0f 00 00 4f b0 0f
# 00b8: 04 ff 00 a0 0f 04 ff 02
# 00c0: b0 0f 04 ff 00 a0 06 42
# 00c8: 20 b0 06 12 b0 16 12 a0
# 00d0: 0f 04 01 35 a0 1f 04 01
# 00d8: 33 b0 0f 04 ff 00 74 01
# 00e0: a0 16 42 a0 06 42 20 b0
# 00e8: 16 12 b0 26 12 b0 36 12
# 00f0: b0 46 12 a0 4f 00 00 02
# 00f8: a0 3f 00 00 10 a0 1f 00
# 0100: 00 00 a0 0f 00 ff ff a0
# 0108: 21 03 01 39 74 20 53 ff
# 0110: 00 01 18 50 ff 00 01 1d
# 0118: a0 01 03 01 39 70 14 74
# 0120: 13 52 f7 05 ff e1 a0 46
# 0128: 42 a0 36 42 a0 26 42 a0
# 0130: 16 42 40 54 00 43 00 00
# 0138: 00 04 00 03 00 04 00 08
# 0140: 00 01 00 00 00 06 00 03
# 0148: 00

test3

ASSEMBLER=/home/ss/Desktop/Projekat/asembler
LINKER=/home/ss/Desktop/Projekat/linker
EMULATOR=/home/ss/Desktop/Projekat/emulator

${ASSEMBLER} -o main.o main.s
${ASSEMBLER} -o interrupts.o interrupts.s
${LINKER} -hex -place=ivt@0x0000 -o test3.hex interrupts.o main.o
${EMULATOR} test3.hex

# linker

# 0000: 10 00 00 00 15 00 26 00
# 0008: 00 00 00 00 00 00 00 00
# 0010: 50 ff 00 00 4e b0 06 12
# 0018: a0 0f 00 00 54 b0 0f 04
# 0020: ff 00 a0 06 42 20 b0 06
# 0028: 12 b0 16 12 a0 0f 04 ff
# 0030: 02 b0 0f 04 ff 00 a0 07
# 0038: 03 00 2f a0 1f 00 00 01
# 0040: 70 01 b0 0f 04 00 6a a0
# 0048: 16 42 a0 06 42 20 a0 0f
# 0050: 00 00 01 b0 0f 04 ff 10
# 0058: a0 0f 04 00 6a a0 1f 00
# 0060: 00 05 74 01 52 ff 00 00
# 0068: 58 00 00 00

*/



/*
{
  "tasks": [
    {
      "type": "cppbuild",
      "label": "C/C++: g++ build project(projekat)",
      "command": "/usr/bin/g++",
      "args": [
        "-fdiagnostics-color=always",
        "-g",
        "-o",
        "${workspaceFolder}/projekat",
        "${workspaceFolder}/inc/*.hpp",
        "${workspaceFolder}/src/*.cpp"
      ],
      "options": {
        "cwd": "${workspaceFolder}"
      },
      "problemMatcher": [
        "$gcc"
      ],
      "group": {
        "kind": "build",
        "isDefault": true
      },
      "detail": "Task generated by Debugger."
    }
  ],
  "version": "2.0.0"
}


*/


// functions that make relocation data -> processWordDirective

// constructor
Assembler::Assembler(string inputFile, string outputFile) {
  this->inputFilePath = inputFile;
  this->outputFilePath = outputFile;
  this->locationCounter = 0;
  this->currLineNumber = 0;
  this->currSection = "";

  // undefined section
  SectionTable undSection;
    undSection.sectionId = idCountSectionTable++;
    undSection.size = 0;
    undSection.sectionName = "UND";

    sectionTable["UND"] = undSection;
    // UNDEFINED is symbol so it has to be in symbol table
    SymbolTable undSymbol;
    undSymbol.symbolId = idCountSymbolTable++;
    undSymbol.value = 0;
    undSymbol.isDefined = true;
    undSymbol.isExtern = false;
    undSymbol.isGlobal = false; 
    undSymbol.section = "UND";
    undSymbol.symbolName = "UND";
    symbolTable["UND"] = undSymbol;

    // // Absolute section
    SectionTable absSection;
    absSection.sectionId = -1;
    absSection.size = 0;
    absSection.sectionName = "ABS";
    sectionTable["ABS"] = absSection;
    // ABS is symbol so it has to be in symbol table
    SymbolTable absSymbol;
    absSymbol.symbolId = idCountSymbolTable++;
    absSymbol.value = 0;
    absSymbol.isDefined = true;
    absSymbol.isExtern = false;
    absSymbol.isGlobal = false;
    absSymbol.section = "ABS";
    absSymbol.symbolName = "ABS";
    symbolTable["ABS"] = absSymbol;

}

// makes text file which is human readable
void Assembler::makeTextFile() {
  string outputPath = regex_replace(outputFilePath, file, "$1");
  
  ofstream outputFile(outputPath + ".txt");

  // Copy it into a vector.
  vector<pair<string, SectionTable>> vector2(sectionTable.begin(), sectionTable.end());
  vector<pair<string, SymbolTable>> vector(symbolTable.begin(), symbolTable.end());

  // Sort the vector according to the word count in ascending order.
  sort( vector.begin(), vector.end(), 
           []( const auto & lhs, const auto & rhs ) 
           { return lhs.second.symbolId < rhs.second.symbolId; } );

  sort( vector2.begin(), vector2.end(), 
           []( const auto & lhs, const auto & rhs ) 
           { return lhs.second.sectionId < rhs.second.sectionId; } );


// Print out the vector.
// for ( const auto & item : vector )
//     outputFile << item.first << ": " << item.second.symbolId << endl;  

  // outputFile << endl;
  // First print symbol table
  outputFile << "Symbol Table:" << endl << "\tId\t\tValue\t\tBind\t\tSection\t\tName"
    << endl << "\t--\t\t-----\t\t----\t\t-------\t\t----" << endl;

  for (const auto& it : vector) {
    
    outputFile << hex << setfill('0') << setw(4) << (0xffff & it.second.symbolId) << "\t\t";
    outputFile << hex << setfill('0') << setw(4) << (0xffff & it.second.value) << "\t\t";

    if (!it.second.isGlobal) outputFile << "\tLOC\t\t\t";  // local
    else if (it.second.isDefined) outputFile << "\tGLOB\t\t\t"; // global
    else if (it.second.isExtern) outputFile << "\tEXT\t\t\t";  // extern
    else outputFile << "\tUN\t\t\t"; // undefined

    outputFile << it.second.section << "\t\t\t\t" << it.second.symbolName << "\t\t\t" << endl;
  }
  outputFile << endl;
  // Then print section table
  outputFile << "Section Table:" << endl;
  outputFile << "Id\t\tName\t\t\tSize" << endl;
  outputFile << "--\t\t----\t\t\t----" << endl;
  for (const auto& it : vector2) {
    outputFile << hex << setfill('0') << setw(4) << (0xffff & it.second.sectionId) << "\t" 
    << it.second.sectionName << "\t\t\t" << 
      hex << setfill('0') << setw(4) << (0xffff & it.second.size) << endl;
  }
  outputFile << endl;
  for (map<string, SectionTable>::iterator it = sectionTable.begin(); it != sectionTable.end(); it++) {
    if (it->first != "ABS") {
      outputFile << endl << "#.rela." << it->first << endl;
      outputFile << "Offset\t\tType\t\t\tSymbol\tSection name" << endl;
      for (RelocationTable data : relocationTable) {
        if (data.sectionName != it->first) continue;
        // if (!symbolTable[data.symbolName].isGlobal) continue;
        outputFile << hex << setfill('0') << setw(4) << (0xffff & data.offset) << "\t" 
          << data.type << "\t\t\t" << "\t\t\t\t" << data.symbolName 
          << "\t\t\t" << data.sectionName << endl;
      }
    }

    outputFile << endl;

    outputFile << "#." << it->first << endl;

    SectionTable secTab = it->second;
    if (secTab.size == 0) {
      outputFile << endl << endl;
      continue;
    }
    int counter = 0;

    for (int i = 0; i < secTab.offset.size() - 1; i++) {
      int currOffset = secTab.offset[i];
      int nextOffset = secTab.offset[i + 1];
      outputFile << hex << setfill('0') << setw(4) << (0xffff & currOffset) << ": ";
      for (int j = currOffset; j < nextOffset; j++) {
        char c = secTab.info[j];
        outputFile << hex << setfill('0') << setw(2) << (0xff & c) << " ";
      }
      outputFile << endl;
    }
    // Last one
    int currOffset = secTab.offset[secTab.offset.size() - 1];
    int nextOffset = secTab.info.size();
    outputFile << hex << setfill('0') << setw(4) << (0xffff & currOffset) << ": ";
    for (int j = currOffset; j < nextOffset; j++) {
      char c = secTab.info[j];
      outputFile << hex << setfill('0') << setw(2) << (0xff & c) << " ";
    }

  }

  // for (const auto& it : sectionTable["text"]) {
  //   cout << it.second.off
  // }

  outputFile.close();

}

// makes binary file for linker
void Assembler::makeBinaryFile() {

  string binFilenameOutput = outputFilePath;
  ofstream binOutFile(binFilenameOutput, ios::out | ios::binary);
  if (binOutFile.fail()) {
    cout << "Asembler error: File " + binFilenameOutput + " is invalid!" << endl;
    return;
  }

  int len = 0;

  // Symbol table
  int symNum = symbolTable.size();
  binOutFile.write((char *)&symNum, sizeof(symNum));

  for (map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
    string key = it->first;
    // key
    len = key.length();
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(key.c_str(), key.length());
    // symbol id
    binOutFile.write((char*)(&it->second.symbolId), sizeof(it->second.symbolId));
    // value
    binOutFile.write((char*)(&it->second.value), sizeof(it->second.value));
    binOutFile.write((char*)(&it->second.isDefined), sizeof(it->second.isDefined));
    binOutFile.write((char*)(&it->second.isGlobal), sizeof(it->second.isGlobal));
    binOutFile.write((char*)(&it->second.isExtern), sizeof(it->second.isExtern));
    // section name
    len = it->second.section.length();
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(it->second.section.c_str(), it->second.section.length());
    // symbol name
    len = it->second.symbolName.length();
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(it->second.symbolName.c_str(), it->second.symbolName.length());

  }

  // Section table:
  int secNum = sectionTable.size();
  binOutFile.write((char*)&secNum, sizeof(secNum));

  for (map<string, SectionTable>::iterator it = sectionTable.begin(); it != sectionTable.end(); it++) {
    string key = it->first;
    len = key.length();
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(key.c_str(), key.length());
    // section id
    binOutFile.write((char*)(&it->second.sectionId), sizeof(it->second.sectionId));
    // size
    binOutFile.write((char*)(&it->second.size), sizeof(it->second.size));
    len = it->second.sectionName.length();
    // offset
    int offNum = it->second.offset.size();
    binOutFile.write((char*)&offNum, sizeof(offNum));
    for (int o : it->second.offset) binOutFile.write((char *)&o, sizeof(o));
    // info
    int charNum = it->second.info.size();
    binOutFile.write((char*)&charNum, sizeof(charNum));
    for (char c : it->second.info) {
     binOutFile.write((char *)&c, sizeof(c));
    }
  
    // section name
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(it->second.sectionName.c_str(), it->second.sectionName.length());
  }
  // Relocation
  
  int relNum = relocationTable.size();
  // int cnt = 0;
  // for (const auto& rel : relocationTable) {
  //  if (!symbolTable[rel.symbolName].isGlobal) cnt++;
  // }
  //relNum -= cnt;
  binOutFile.write((char*)&relNum, sizeof(relNum));
  
  for (RelocationTable relData : relocationTable) {
    //if (!symbolTable[relData.symbolName].isGlobal) continue;
    binOutFile.write((char*)(&relData.offset), sizeof(relData.offset));
    binOutFile.write((char*)(&relData.isInfo), sizeof(relData.isInfo));
    // section name
    len = relData.sectionName.length();
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(relData.sectionName.c_str(), relData.sectionName.length());
    // symbol name
    len = relData.symbolName.length();
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(relData.symbolName.c_str(), relData.symbolName.length());
    // type
    len = relData.type.length();
    binOutFile.write((char*)(&len), sizeof(len));
    binOutFile.write(relData.type.c_str(), relData.type.length());
  }
  binOutFile.close();
}

// some cases:
// not in section, already defined, extern(defined in another module)
// adds label to symbol table
bool Assembler::processLabel(string label) {
  if (this->currSection == "") {
    cout << "Error on line " << this->currLineNumber << ": Label " << label
    << " has to be in section!" << endl;
    return false;
  }
  else {  // it is in section
    for(map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
      if (it->second.symbolName == label && it->second.isExtern) {
        cout << "Error on line " << this->currLineNumber << ": Label " << label
          << " is defined in another file!" << endl;
        return false;
      }
      else if (it->second.symbolName == label && it->second.value == -1) {
        if (it->second.isGlobal) it->second.isGlobal = true;
        else it->second.isGlobal = false;

        it->second.isDefined = true;
        it->second.isExtern = false;

        it->second.section = this->currSection;
        it->second.value = this->locationCounter;
        return true;
      }
      else if (it->second.symbolName == label && it->second.isGlobal) {
        it->second.isDefined = true;
        it->second.isExtern = false;
        it->second.section = this->currSection;
        it->second.value = this->locationCounter;
        return true;
      }
      else if (it->second.symbolName == label) {  // should I add for symbolName + "Local"
        cout << "Error on line " << this->currLineNumber << ": Multiple definition of label" + label
          << endl;
        return false;
      }
    }
    // everything allright, lets add it to symbolTable
    SymbolTable newLabel;
    newLabel.isDefined = true;
    newLabel.isExtern = false;
    newLabel.isGlobal = false;
    newLabel.section = this->currSection;
    newLabel.symbolId = idCountSymbolTable++;
    newLabel.symbolName = label;
    newLabel.value = this->locationCounter;
    symbolTable[label] = newLabel;
    return true;
  }
}

// some cases:
// already defined, end of previous section
// adds a section in section table and resets the locationCounter and puts 
// the name in currSection variable
bool Assembler::processSection(string section) {
  this->locationCounter = 0;
  this->currSection = section;


  // put it in section table
  SectionTable newSection;
  newSection.sectionId = idCountSectionTable++;
  newSection.sectionName = section;
  newSection.size = 0;
  sectionTable[section] = newSection;

  // and put it in symbol table
  SymbolTable newSecSymbol;
  newSecSymbol.isDefined = true;
  newSecSymbol.isExtern = false;
  newSecSymbol.isGlobal = false;
  newSecSymbol.section = this->currSection;
  newSecSymbol.symbolId = idCountSymbolTable++;
  newSecSymbol.symbolName = section;
  newSecSymbol.value = this->locationCounter;
  symbolTable[section] = newSecSymbol;

  return true;
}

// already defined(make global)
// adds symbol to symbolTable and classifies it as global, or if it's allready
// in symbol table then it just changes it to global
void Assembler::processGlobalSymbol(string symbol) {
  for(map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
    // if it's mentioned before but value of symbol is unknown
    if (it->second.symbolName == symbol && it->second.value == -1) {
      it->second.isDefined = false;
      it->second.isExtern = false;
      it->second.isGlobal = true;
      it->second.section = "UND";
      it->second.value = 0;
      return;
    }
    if (it->second.symbolName == symbol && it->second.isGlobal) {
      cout << "Message: Already defined global symbol." << endl;
      return;
    }
    else if (it->second.symbolName == symbol) {
      it->second.isGlobal = true;
      return;
    }
  }
  // not defined
  SymbolTable newSymbol;
  newSymbol.isDefined = false;
  newSymbol.isExtern = false;
  newSymbol.isGlobal = true;
  newSymbol.section = "UND";
  newSymbol.symbolId = idCountSymbolTable++;
  newSymbol.symbolName = symbol;
  newSymbol.value = 0;
  symbolTable[symbol] = newSymbol;
}

// already defined
// adds symbol to symbolTable and classifies it as extern
bool Assembler::processExternSymbol(string symbol) {
  for (map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
    // if it's mentioned before but value of symbol is unknown
    if (it->second.symbolName == symbol && it->second.value == -1) {
      it->second.isDefined = false;
      it->second.isExtern = true;
      it->second.isGlobal = true;
      it->second.section = "UND";
      it->second.value = 0;
      return true;
    }
    if (it->second.symbolName == symbol) {
      cout << "Error on line " << this->currLineNumber << ": Multiple definition of symbol "
      << symbol << "!" << endl;
      return false;
    }
  }
  SymbolTable newSymbol;
  newSymbol.isDefined = false;
  newSymbol.isExtern = true;
  newSymbol.isGlobal = true;
  newSymbol.section = "UND";
  newSymbol.symbolId = idCountSymbolTable++;
  newSymbol.symbolName = symbol;
  newSymbol.value = 0;
  symbolTable[symbol] = newSymbol;
  return true;
}

// not in section
// alocates two bytes of data
bool Assembler::processWordDirective(string word) {
  if (this->currSection == "") {
    cout << "Error on line " << this->currLineNumber << ": word directive has to be in section!" << endl;
    return false;
  }
  else {
    sectionTable[this->currSection].size += 2;
    if (regex_match(word, sym)) {
      int found = 0;
      for (map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
        // exists in symbol table but it's value is -1, which means that it's not defined yet
        if (it->second.symbolName == word && it->second.value == -1) {
          found = 1;
          Flink f;
          f.sign = '+';
          f.address = this->locationCounter;
          f.symbolName = word;
          f.sectionName = this->currSection;
          flink.push_back(f);

          // creating relocation data 
          RelocationTable newData;
          newData.isInfo = true;
          newData.type = "R_16";
          newData.sectionName = this->currSection;
          newData.offset = this->locationCounter;
          newData.symbolName = it->second.symbolName;
          newData.addend = -1000;
          relocationTable.push_back(newData);
          break;
        }
        if (it->second.symbolName == word) {  // exists in symbol table
          found = 1;
          if (it->second.section == "ABS") {
            sectionTable[this->currSection].offset.push_back(this->locationCounter);
            sectionTable[this->currSection].info.push_back(0xff & it->second.value);  // lower byte
            sectionTable[this->currSection].info.push_back(0xff & (it->second.value >> 8));
          }
          else {  // not in ABS section
            if (it->second.isDefined) {
              if (it->second.isGlobal) {  // if it is global then we add zeroes to data
                sectionTable[this->currSection].offset.push_back(this->locationCounter);
                sectionTable[this->currSection].info.push_back(0xff & 0);
                sectionTable[this->currSection].info.push_back(0xff & 0);
                // creating relocation data 
                RelocationTable newData;
                newData.isInfo = true;
                newData.type = "R_16";
                newData.sectionName = this->currSection;
                newData.offset = this->locationCounter;
                newData.symbolName = it->second.symbolName;
                newData.addend = 0;
                relocationTable.push_back(newData);
              }
              else {  // local symbol
                // add value of symbol to data
                sectionTable[this->currSection].offset.push_back(this->locationCounter);
                sectionTable[this->currSection].info.push_back(it->second.value & 0xff);
                sectionTable[this->currSection].info.push_back((it->second.value >> 8) & 0xff);
                // create relocation data for section
                RelocationTable newData;
                newData.isInfo = true;
                newData.type = "R_16";
                newData.sectionName = this->currSection;
                newData.offset = this->locationCounter;
                newData.symbolName = it->second.section;
                newData.addend = it->second.value;
                relocationTable.push_back(newData);
              }
            }
            else {  // not defined
              // add zeros to data
              sectionTable[this->currSection].offset.push_back(this->locationCounter);
              sectionTable[this->currSection].info.push_back(0 & 0xff);
              sectionTable[this->currSection].info.push_back(0 & 0xff);
              // create relocation data for this symbol
              RelocationTable newData;
              newData.isInfo = true;
              newData.type = "R_16";
              newData.sectionName = this->currSection;
              newData.offset = this->locationCounter;
              newData.symbolName = it->second.symbolName;
              newData.addend = -1000;
              relocationTable.push_back(newData);
            }
          }
        }
      } // end of for
      if (found == 0) { // if it doesn't exists in symbol table
        // add to symbol table
        SymbolTable newSymbol;
        newSymbol.isDefined = false;
        newSymbol.isExtern = false;
        newSymbol.isGlobal = false;
        newSymbol.section = "";
        newSymbol.symbolId = idCountSymbolTable++;
        newSymbol.symbolName = word;
        newSymbol.value = -1;
        symbolTable[word] = newSymbol;

        // create relocation data for this symbol
        RelocationTable newData;
        newData.isInfo = true;
        newData.type = "R_16";
        newData.sectionName = this->currSection;
        newData.offset = this->locationCounter;
        newData.symbolName = word;
        newData.addend = -1000;
        relocationTable.push_back(newData);

        sectionTable[this->currSection].offset.push_back(this->locationCounter);
        sectionTable[this->currSection].info.push_back(0xff & newSymbol.value);
        sectionTable[this->currSection].info.push_back(0xff & (newSymbol.value >> 8));

        Flink f;
        f.sign = '+';
        f.address = this->locationCounter;
        f.symbolName = word;
        f.sectionName = this->currSection;
        flink.push_back(f);
      }
    }
    else {  // if it is a number
        char c = this->castLiteralToDecimalValue(word);
        sectionTable[this->currSection].offset.push_back(this->locationCounter);
        sectionTable[this->currSection].info.push_back(0xff & c);
        sectionTable[this->currSection].info.push_back(0xff & (c >> 8));
    }
  }
  this->locationCounter += 2;
  return true;
}

// not in section
// adds number of bytes which are given in parameter of function
bool Assembler::processSkipDirective(string value) {
  if (this->currSection == "") {
    cout << "Error on line " << this->currLineNumber << ": skip directive has to be in section!" << endl;
    return false;
  }
  else {
    int val = this->castLiteralToDecimalValue(value);
    sectionTable[this->currSection].size += val;
    sectionTable[this->currSection].offset.push_back(this->locationCounter);
    for (int i = 0; i < val; i++)
      sectionTable[this->currSection].info.push_back(0);  // fill it with zeroes
    this->locationCounter += val;
    return true;
  }
}

// creates a string and puts it in section content
bool Assembler::processAsciiDirective(string str) {
  if (this->currSection == "") {
    cout << "Error on line " << this->currLineNumber << ": ascii directive has to be in section!" << endl;
    return false;
  }
  else {
    sectionTable[this->currSection].offset.push_back(this->locationCounter);
    int cnt = 0;
    for (char c: str) {
      sectionTable[this->currSection].info.push_back(int(c) & 0xff);
      //sectionTable[this->currSection].info.push_back((int(c) >> 8) & 0xff);
      cnt++;
    }
    sectionTable[this->currSection].size += cnt;
    this->locationCounter += cnt;
    return true;
  }
}

// already defined, extern symbol
// defines a symbol
bool Assembler::processEquDirective(string name, string value) {
  for (map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
    if (it->second.symbolName == name && it->second.isExtern) {
      cout << "Error on line " << this->currLineNumber << " : Equ directive cannot define extern symbol "
      << name << "!" << endl;
      return false;
    }
    else if (it->second.symbolName == name && it->second.isDefined) {
      cout << "Error on line " << this->currLineNumber << " : Equ cannot define symbol that is already"
      << " defined!" << endl;
      return false;
    }
    else if (it->second.symbolName == name) {
      it->second.isDefined = true;
      it->second.section = "ABS";
      it->second.value = this->castLiteralToDecimalValue(value);
      sectionTable["ABS"].offset.push_back(sectionTable["ABS"].size);
      sectionTable["ABS"].size += 2;
      sectionTable["ABS"].info.push_back(0xff & it->second.value);
      sectionTable["ABS"].info.push_back(0xff & (it->second.value >> 8));
      return true;
    }
  }
  // symbol not defined
  SymbolTable newSymbol;
  newSymbol.isDefined = true;
  newSymbol.isExtern = false;
  newSymbol.isGlobal = false;
  newSymbol.section = "ABS";
  newSymbol.symbolId = idCountSymbolTable++;
  newSymbol.symbolName = name;
  newSymbol.value = this->castLiteralToDecimalValue(value);
  symbolTable[name] = newSymbol;

  sectionTable["ABS"].offset.push_back(sectionTable["ABS"].size);
  sectionTable["ABS"].size += 2;
  sectionTable["ABS"].info.push_back(0xff & newSymbol.value);
  sectionTable["ABS"].info.push_back(0xff & newSymbol.value >> 8);
  return true;
}

// if relocation type is absolute
int Assembler::processAbsoluteAddressingSymbol(string symbol) {
  int found = 0;
  for (map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
    // mentioned but not defined
    if (it->second.symbolName == symbol && it->second.value == -1) {
      Flink f;
      f.sign = '+';
      f.address = this->locationCounter;
      f.symbolName = symbol;
      f.sectionName = this->currSection;
      flink.push_back(f);
      // cout << hex << (int)this->locationCounter << endl;
      // cout << hex << (int)this->locationCounter + 4 << endl;
      RelocationTable newData;
      newData.isInfo = false; // need to use big endian because it is an instruction
      newData.offset = this->locationCounter + 4;
      newData.sectionName = this->currSection;
      newData.type = "R_16";
      newData.symbolName = symbol;
      newData.addend = -1000;
      relocationTable.push_back(newData);
      return 0;
    }
    if (it->second.symbolName == symbol) {
      found = 1;
      if (it->second.section == "ABS") return it->second.value;
      else {
        RelocationTable newData;
        newData.isInfo = false;
        newData.offset = this->locationCounter + 4; 
        newData.sectionName = this->currSection;
        newData.type = "R_16";
      // cout << hex << (int)this->locationCounter << endl;
      // cout << hex << (int)this->locationCounter + 4 << endl;
        int symVal = 0;
        // if it is global or extern symbol name should be in relocation table
        if (it->second.isGlobal || it->second.isExtern) {
          newData.symbolName = symbol;
          newData.addend = 0;
          symVal = 0;
        }
        else {  // else put a section name
          //newData.symbolName = it->second.section;
          newData.symbolName = symbol;
          newData.addend = it->second.value;
          symVal = it->second.value;
        }
        relocationTable.push_back(newData);
        return symVal;
      }
    }
  }
  if (found == 0) { // it doesn't exists in symbol table
    SymbolTable newSymbol;
    newSymbol.isDefined = false;
    newSymbol.isExtern = false;
    newSymbol.isGlobal = false;
    newSymbol.section = "";
    newSymbol.symbolId = idCountSymbolTable++;
    newSymbol.symbolName = symbol;
    newSymbol.value = -1;
    symbolTable[symbol] = newSymbol;
      // cout << hex << (int)this->locationCounter << endl;
      // cout << hex << (int)this->locationCounter + 4 << endl;
    RelocationTable newData;
    newData.isInfo = false; // need to use big endian because it is an instruction
    newData.offset = this->locationCounter + 4;
    newData.sectionName = this->currSection;
    newData.type = "R_16";
    newData.symbolName = symbol;
    newData.addend = -1000;

    relocationTable.push_back(newData);

    Flink f;
    f.sign = '+';
    f.address = this->locationCounter;
    f.symbolName = symbol;
    f.sectionName = this->currSection;
    flink.push_back(f);
    return 0;
  }
  return 0;
}

// if relocation type is PC relative
int Assembler::processPCRelativeAddressingSymbol(string symbol) {
  int found = 0;
  int ret = -2;
  for (map<string, SymbolTable>::iterator it = symbolTable.begin(); it != symbolTable.end(); it++) {
    // mentioned before but not defined
    if (it->second.symbolName == symbol && it->second.value == -1) {
      Flink f;
      f.sign = '+';
      f.address = this->locationCounter;
      f.symbolName = symbol;
      f.sectionName = this->currSection;
      flink.push_back(f);
//       cout << hex << this->locationCounter << endl;
// cout << hex << this->locationCounter + 4 << endl;
      RelocationTable newData;
      newData.isInfo = false;
      newData.offset = this->locationCounter + 4; 
      newData.sectionName = this->currSection;
      newData.type = "R_PC16";
      newData.symbolName = it->second.symbolName;
      newData.addend = -1000;
      relocationTable.push_back(newData);
      return ret;
    }
    if (it->second.symbolName == symbol) {
      found = 1;
      if (it->second.section == "ABS") {
        RelocationTable newData;
        newData.isInfo = false;
        // cout << hex << this->locationCounter << endl;
        // cout << hex << this->locationCounter + 4 << endl;
        newData.offset = this->locationCounter + 4; 
        newData.sectionName = this->currSection;
        newData.type = "R_PC16";
        newData.symbolName = it->second.symbolName;
        newData.addend = -2;  // not sure of this
        relocationTable.push_back(newData);
        return ret;
      }
      else {
        RelocationTable newData;
        newData.isInfo = false;
        // cout << hex << this->locationCounter << endl;
        // cout << hex << this->locationCounter + 4 << endl;
        newData.offset = this->locationCounter + 4; 
        newData.sectionName = this->currSection;
        newData.type = "R_PC16";

        int symVal = 0;
        if (it->second.isGlobal || it->second.isExtern) {
          newData.symbolName = symbol;
          newData.addend = it->second.value - 2;  // value of symbol - amount till nextPC
          symVal = ret;
        }
        else {
          // if the mentioned symbol is in same section in which is defined and 
          // the type of relocation is PC relative then offset is always the same
          if (this->currSection == it->second.section) {
            symVal = it->second.value + ret - (this->locationCounter + 3);
            newData.addend = it->second.value - 2 - (this->locationCounter + 3);
            return symVal;
          }
          else {  // different section
            newData.symbolName = it->second.section;
            newData.addend = it->second.value - 2;
            symVal = it->second.value + ret;
          }
        }
        relocationTable.push_back(newData);
        return symVal;
      }
    }
  }
  if (found == 0) { // it doesn't exists in symbol table
    SymbolTable newSymbol;
    newSymbol.isDefined = false;
    newSymbol.isExtern = false;
    newSymbol.isGlobal = false;
    newSymbol.section = "";
    newSymbol.symbolId = idCountSymbolTable++;
    newSymbol.symbolName = symbol;
    newSymbol.value = -1;
    symbolTable[symbol] = newSymbol;

    Flink f;
    f.sign = '+';
    f.address = this->locationCounter;
    f.symbolName = symbol;
    f.sectionName = this->currSection;
    flink.push_back(f);
    // cout << hex << this->locationCounter << endl;
    // cout << hex << this->locationCounter + 4 << endl;
    RelocationTable newData;
    newData.isInfo = false;
    newData.offset = this->locationCounter + 4; 
    newData.sectionName = this->currSection;
    newData.type = "R_PC16";
    newData.symbolName = symbol;
    newData.addend = -1000;
    relocationTable.push_back(newData);
    return ret;
  }
  return 0;
}

// creates decimal value from string
int Assembler::castLiteralToDecimalValue(string literal) {
  smatch number;
  int num;
  if (regex_search(literal, number, literalHexadecimal)) {
      stringstream ss;
      ss << number.str(1).substr(2);
      ss >> hex >> num;       
  }
  else {
      regex_search(literal, number, literalDecimal);
      num = stoi(number.str(1));

  }
  return num;
}

// converts from decimal value to hexadecimal
string Assembler::decToHex(int decValue) {
    stringstream ss;
    ss << hex << decValue;
    string res(ss.str());

    return res;
}

// main public asembler function
bool Assembler::compile() {
  if (!pass()) return false;
  makeTextFile();
  makeBinaryFile();
  return true;
}

// recognizes instruction and fills in section content
bool Assembler::processInstruction(string instr) {
  if (this->currSection == "") {
    cout << "Error on line " << this->currLineNumber << ": instruction has to be in section!" << endl;
    return false;
  }
  smatch tokens;

  if (regex_search(instr, tokens, noOperandInstr)) {
    // halt, iret, ret is 1B
    string instrMnemonic = tokens.str(1);
    if (instrMnemonic == "halt") {
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(0x00);
    }
    else if (instrMnemonic == "iret") {
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(0x20);
    }
    else if (instrMnemonic == "ret") {
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(0x40);
    }
    this->locationCounter += 1;
    sectionTable[this->currSection].size += 1;
  }
  else if (regex_search(instr, tokens, oneOperandInstr)) {
    // push r, pop r, int r, not r (2B is int and not and 3B is push and pop)
    string instrMnemonic = tokens.str(1);
    int regNum;
    if (tokens.str(2) == "psw") regNum = 8;
    else regNum = tokens.str(2).at(1) - '0';
  

    if (instrMnemonic == "int") {
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(0x10);
      sectionTable[this->currSection].info.push_back((regNum << 4) + 15);
      this->locationCounter += 2;
      sectionTable[this->currSection].size += 2;
    }
    else if (instrMnemonic == "push") {
      // instruction push: sp -= 2, mem[sp] = reg
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(0xB0);
      sectionTable[this->currSection].info.push_back((regNum << 4) + 6);
      sectionTable[this->currSection].info.push_back(0x12);
      this->locationCounter += 3;
      sectionTable[this->currSection].size += 3;
    }
    else if (instrMnemonic == "pop") {
      // instruction pop: reg = mem[sp], sp -= 2
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(0xA0);
      sectionTable[this->currSection].info.push_back((regNum << 4) + 6);
      sectionTable[this->currSection].info.push_back(0x42);
      this->locationCounter += 3;
      sectionTable[this->currSection].size += 3;
    }
    else if (instrMnemonic == "not") {
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(0x80);
      sectionTable[this->currSection].info.push_back((regNum << 4) + 15);
      this->locationCounter += 2;
      sectionTable[this->currSection].size += 2;
    }
  }
  else if (regex_search(instr, tokens, jumps)) {
    string instrMnemonic = tokens.str(1);
    string operand = tokens.str(2);
    int regDescr = 0xF0;
    int instrDescr;
    smatch tokensOperand;
    int adrMode;
    if (instrMnemonic == "call") instrDescr = 0x30;
    else if (instrMnemonic == "jmp") instrDescr = 0x50;
    else if (instrMnemonic == "jeq") instrDescr = 0x51;
    else if (instrMnemonic == "jne") instrDescr = 0x52;
    else if (instrMnemonic == "jgt") instrDescr = 0x53;
    if (regex_search(operand, tokensOperand, jmpAbsolute)) {
      if (regex_match(operand, sym)){ // symbol, format: jmp symbol
        regDescr += 0xF;
        adrMode = 0;

        int val = processAbsoluteAddressingSymbol(operand);
        sectionTable[this->currSection].offset.push_back(this->locationCounter);
        sectionTable[this->currSection].info.push_back(instrDescr);
        sectionTable[this->currSection].info.push_back(regDescr);
        sectionTable[this->currSection].info.push_back(adrMode);
        sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
        sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
        this->locationCounter += 5;
        sectionTable[this->currSection].size += 5;
      }
      else {  // number, format jmp number
        int val = this->castLiteralToDecimalValue(operand);
        regDescr += 0xF;
        adrMode = 0;
        sectionTable[this->currSection].offset.push_back(this->locationCounter);
        sectionTable[this->currSection].info.push_back(instrDescr);
        sectionTable[this->currSection].info.push_back(regDescr);
        sectionTable[this->currSection].info.push_back(adrMode);
        sectionTable[this->currSection].info.push_back(0xff & (val >> 8));
        sectionTable[this->currSection].info.push_back(0xff & (val));
        this->locationCounter += 5;
        sectionTable[this->currSection].size += 5;
      }
    }
    else if (regex_search(operand, tokensOperand, jmpPCRelative)) { // format jmp %reg
      operand = tokensOperand.str(1);
      regDescr += 0x7;
      adrMode = 0x05;

      int val = processPCRelativeAddressingSymbol(operand);

      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
      sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
      this->locationCounter += 5;
      sectionTable[this->currSection].size += 5;
    }
    else if (regex_search(operand, tokensOperand, jmpRegdir)) { // format jmp *reg
      int regNum;
      if (tokensOperand.str(1) == "psw") regNum = 8;       
      else regNum = tokensOperand.str(1).at(1) - '0';
      regDescr += regNum;
      adrMode = 0x01;
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      this->locationCounter += 3;
      sectionTable[this->currSection].size += 3;
    }
    else if (regex_search(operand, tokensOperand, jmpMemdir)) { // format jmp *symbol
      operand = tokensOperand.str(1);
      regDescr += 0xF;
      adrMode = 0x04;
      int val;

      // it can be a symbol or a number (immediate value)
      if (regex_match(operand, sym)) val = this->processAbsoluteAddressingSymbol(operand);
      else val = this->castLiteralToDecimalValue(operand);
    
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
      sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
      this->locationCounter += 5;
      sectionTable[this->currSection].size += 5;
    }
    else if (regex_search(operand, tokensOperand, jmpRegind)) { // format jmp *[reg]
      int regNum;
      if (tokensOperand.str(1) == "psw") regNum = 8;
      else regNum = tokensOperand.str(1).at(1) - '0';
            
      regDescr += regNum;
      adrMode = 0x02;
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      this->locationCounter  += 3;
      sectionTable[this->currSection].size += 3;
    }
    else if (regex_search(operand, tokensOperand, jmpRegindWithDisplacement)) { 
      // format jmp *[reg + symbol]
      string displacement = tokensOperand.str(2);
      int regNum;
      if (tokensOperand.str(1) == "psw") regNum = 8;
      else regNum = tokensOperand.str(1).at(1) - '0';
      
      regDescr += regNum;
      adrMode = 0x03;
      int val;
      // it can be a symbol or number
      if (regex_match(displacement, sym)) val = this->processAbsoluteAddressingSymbol(displacement);
      else val = this->castLiteralToDecimalValue(displacement);

      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
      sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
      this->locationCounter  += 5;
      sectionTable[this->currSection].size += 5;
    }
  } // end of jumps

  // beginning of load and store instruction
  else if (regex_search(instr, tokens, loadStore)) {
    string instrMnemonic = tokens.str(1);
    string regD = tokens.str(2);
    string operand = tokens.str(3);
    smatch tokensOperand;

    int instrDescr;
    int regDescr;
    int adrMode;
    if (instrMnemonic == "ldr") instrDescr = 0xA0; 
    else if (instrMnemonic == "str") instrDescr = 0xB0;    
    if (regD == "psw") regDescr = 0x8; 
    else regDescr = regD.at(1) - '0'; 
    regDescr <<= 4;
    if (regex_search(operand, tokensOperand, loadStoreAbsolute)) {  // ldr reg, $symbol(value)
      operand = tokensOperand.str(1);
      if (regex_match(operand, sym)) {  // if it's a symbol
        regDescr += 0xF;
        adrMode = 0;
        int val = this->processAbsoluteAddressingSymbol(operand);
        sectionTable[this->currSection].offset.push_back(this->locationCounter);
        sectionTable[this->currSection].info.push_back(instrDescr);
        sectionTable[this->currSection].info.push_back(regDescr);
        sectionTable[this->currSection].info.push_back(adrMode);
        sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
        sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
        this->locationCounter += 5;
        sectionTable[this->currSection].size += 5;
      }
      else {  // if it's a number
        int val = this->castLiteralToDecimalValue(operand);

        regDescr += 0xF;
        adrMode = 0;
        sectionTable[this->currSection].offset.push_back(this->locationCounter);
        sectionTable[this->currSection].info.push_back(instrDescr);
        sectionTable[this->currSection].info.push_back(regDescr);
        sectionTable[this->currSection].info.push_back(adrMode);
        sectionTable[this->currSection].info.push_back(0xff & (val >> 8));
        sectionTable[this->currSection].info.push_back(0xff & (val));
        this->locationCounter += 5;
        sectionTable[this->currSection].size += 5;
      }
    }
    else if (regex_search(operand, tokensOperand, loadStorePCRelative)) { // format ldr reg, %symbol(value)
      operand = tokensOperand.str(1);
      regDescr += 0x7;
      adrMode = 0x03;

      int val = this->processPCRelativeAddressingSymbol(operand);

      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
      sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
      this->locationCounter += 5;
      sectionTable[this->currSection].size += 5;
    }
    else if (regex_search(operand, tokensOperand, loadStoreRegdir)) { // ldr reg, reg
      int regNum;
      if (tokensOperand.str(1) == "psw") regNum = 8;   
      else regNum = tokensOperand.str(1).at(1) - '0';
      
      regDescr += regNum;
      adrMode = 0x01;
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      this->locationCounter += 3;
      sectionTable[this->currSection].size += 3;
    }
    else if (regex_search(operand, tokensOperand, loadStoreRegind)) { // ldr reg, [reg]
      int regNum;
      if (tokensOperand.str(1) == "psw") regNum = 8;
      else regNum = tokensOperand.str(1).at(1) - '0';
      
      regDescr += regNum;
      adrMode = 0x02;
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      this->locationCounter += 3;
      sectionTable[this->currSection].size += 3;
    }
    else if (regex_search(operand, tokensOperand, loadStoreRegingWithDisplacement)) {
      // ldr reg, [reg + symbol]
      string displacement = tokensOperand.str(2);
      int regNum;
      if (tokensOperand.str(1) == "psw") regNum = 8;
      
      else regNum = tokensOperand.str(1).at(1) - '0';
    
      regDescr += regNum;
      adrMode = 0x03;
      int val;
      if (regex_match(displacement, sym)) val = this->processAbsoluteAddressingSymbol(displacement); 
      else val = this->castLiteralToDecimalValue(displacement);
      
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
      sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
      this->locationCounter += 5;
      sectionTable[this->currSection].size += 5;
    }
    else if (regex_search(operand, tokensOperand, loadStoreMemdir)) { // ldr reg, symbol(value)
      regDescr += 0xF;
      adrMode = 0x04;
      int val;
      // check if it's a symbol or value
      if (regex_match(operand, sym)) val = this->processAbsoluteAddressingSymbol(operand);
      else val = this->castLiteralToDecimalValue(operand);
      
      sectionTable[this->currSection].offset.push_back(this->locationCounter);
      sectionTable[this->currSection].info.push_back(instrDescr);
      sectionTable[this->currSection].info.push_back(regDescr);
      sectionTable[this->currSection].info.push_back(adrMode);
      sectionTable[this->currSection].info.push_back(0xff & (val >> 8)); // location counter + 3
      sectionTable[this->currSection].info.push_back(0xff & (val));      // location counter + 4
      this->locationCounter += 5;
      sectionTable[this->currSection].size += 5;
    }
    else {
      cout << "Error on line" << this->currLineNumber << ": Addressing type is not supported!" << endl;
      return false;
    }
  } // end of load and store
  else if (regex_search(instr, tokens, twoOperandInstr)) {
    string instrMnemonic = tokens.str(1);
    string regD = tokens.str(2);
    string regS = tokens.str(3);
    smatch tokensOperand;
    
    int instrDescr;
    int regDescr;

    if (instrMnemonic == "xchg") instrDescr = 0x60;   
    else if (instrMnemonic == "add") instrDescr = 0x70;    
    else if (instrMnemonic == "sub") instrDescr = 0x71;      
    else if (instrMnemonic == "mul") instrDescr = 0x72;     
    else if (instrMnemonic == "div") instrDescr = 0x73;       
    else if (instrMnemonic == "cmp") instrDescr = 0x74;     
    else if (instrMnemonic == "and") instrDescr = 0x81;      
    else if (instrMnemonic == "or") instrDescr = 0x82;   
    else if (instrMnemonic == "xor") instrDescr = 0x83;       
    else if (instrMnemonic == "test") instrDescr = 0x84;  
    else if (instrMnemonic == "shl") instrDescr = 0x90;      
    else if (instrMnemonic == "shr") instrDescr = 0x91;
    
    if (regD == "psw") regDescr = 0x8;        
    else regDescr = regD.at(1) - '0';
    
    regDescr <<= 4;
    if (regS == "psw") regDescr += 0x8; 
    else regDescr += regS.at(1) - '0';
    
    sectionTable[this->currSection].offset.push_back(this->locationCounter);
    sectionTable[this->currSection].info.push_back(instrDescr);
    sectionTable[this->currSection].info.push_back(regDescr);
    this->locationCounter += 2;
    sectionTable[this->currSection].size += 2;
  }
  else {
    cout << "Error on line" << this->currLineNumber << ": Instruction is not supported!" << endl;
    return false;
  }
  return true;
}

// asembler passes through the whole file
bool Assembler::pass() {
  ifstream inputFile;
  inputFile.open(inputFilePath);
  if (!inputFile.is_open()) {
    cout << "Asembler error: File " + inputFilePath + " is invalid!" << endl;
    return false;
  }

  currLineNumber = 0;
  bool error = false;
  string line;
  while (getline(inputFile, line)) {  // iterate through file

    // clear file a little
    line = regex_replace(line, removeComment, "$1", regex_constants::format_first_only);
    line = regex_replace(line, removeExtraSpaces, " ");
    line = regex_replace(line, removeTabs, " ");
    line = regex_replace(line, removeExtraSpaces, " "); // do it again
    line = regex_replace(line, removeBoundarySpaces, "$2");
    line = regex_replace(line, findCommaSpaces, ",");
    line = regex_replace(line, findColumnsSpaces, ":");
    this->currLineNumber++;
    smatch tokens;
    //if (regex_search(line, tokens, comment)) continue; // ignore
    if (regex_search(line, tokens, label)) {
      if (!processLabel(tokens.str(1))) error = true;
    }
    else {
      if (regex_search(line, tokens, labelCommand)) {      
        if (!processLabel(tokens.str(1))) error = true;
        line = tokens.str(2);
      }
      if (regex_search(line, tokens, globalDir)) {
        stringstream symbols(tokens.str(1));
        string sym;
        while (getline(symbols, sym, ',')) processGlobalSymbol(sym);
      }
      else if (line == "" || line == " ") {
        continue;
      }
      else if (regex_search(line, tokens, externDir)) {
        stringstream symbols(tokens.str(1));
        string sym;
        while (getline(symbols, sym, ','))
        if (!processExternSymbol(sym)) error = true;
      }
      else if (regex_search(line, tokens, sectionDir)) {
        if (!processSection(tokens.str(1))) error = true;
      }
      else if (regex_search(line, tokens, wordDir)) {
        stringstream symbols(tokens.str(1));
        string sym;
        while (getline(symbols, sym, ','))
          if (!processWordDirective(sym)) error = true;   
      }
      else if (regex_search(line, tokens, skipDir)) {
        if (!processSkipDirective(tokens.str(1))) error = true;
      }
      else if (regex_search(line, tokens, asciiDir)) {
        if (!processAsciiDirective(tokens.str(1))) error = true;
      }
      else if (regex_search(line, tokens, equDir)) {
        if (!processEquDirective(tokens.str(1), tokens.str(2))) error = true;
      }
      else if (regex_search(line, tokens, endDir)) {
        break;  // stop looking file
      }
      else {  // if it isn't directive then it is an instruction
        if (!processInstruction(line)) error = true;
      }
    
    } // if it is not label or comment, then it has to be directive or instruction
  }

  // for (const auto & l : flink) {
  //   cout << hex << (0xff & l.address) << " " << l.symbolName << " " << l.sectionName << endl;
  // }

  // backpatching
  for (const auto& link : flink) {
    // cout << "Link " << link.address << " " << link.symbolName << endl;
    int currOffset = 0;
    int nextOffset  = 0;
    for (int i = 0; i < sectionTable[link.sectionName].offset.size(); i++) {
      if (sectionTable[link.sectionName].offset[i] != link.address) continue;
      
      if (i == sectionTable[link.sectionName].offset.size() - 1) {
        currOffset = sectionTable[link.sectionName].offset[i];
        nextOffset = sectionTable[link.sectionName].info.size();
      }
      else {
        currOffset = sectionTable[link.sectionName].offset[i];
        nextOffset = sectionTable[link.sectionName].offset[i + 1];
      }

      if (nextOffset - currOffset == 5) {
        // cout << "HERE 5 " << hex << currOffset << " " << hex << nextOffset << endl;
        
        sectionTable[link.sectionName].info[currOffset + 3] = ((symbolTable[link.symbolName].value >> 8) & 0xff);
        sectionTable[link.sectionName].info[currOffset + 4] = (symbolTable[link.symbolName].value & 0xff);
      }
      else if (nextOffset - currOffset == 2) {
        // cout << "HERE 2 " << hex << currOffset << " " << hex << nextOffset << endl;
        sectionTable[link.sectionName].info[currOffset] = (symbolTable[link.symbolName].value & 0xff);
        sectionTable[link.sectionName].info[currOffset + 1] = 
          ((symbolTable[link.symbolName].value >> 8) & 0xff);
      }
      else if (nextOffset - currOffset == 3) {
        // cout << "HERE 3 " << hex << currOffset << " " << hex << nextOffset << endl;
        sectionTable[link.sectionName].info[currOffset + 1] = ((symbolTable[link.symbolName].value >> 8) & 0xff);
        sectionTable[link.sectionName].info[currOffset + 2] = (symbolTable[link.symbolName].value & 0xff);     
      }
     
    }
  }

  // TODO: now i need to iterate through relocation data and fix addend, i put default value -1000

  if (error) return false;
  return true;
}